What is PostgreSQL?  
ANS: PostgreSQL হলো একটি ওপেন-সোর্স রিলেশনাল ডেটাবেজ ম্যানেজমেন্ট সিস্টেম (RDBMS), যা ডেটা সংরক্ষণ, পরিচালনা এবং পুনরুদ্ধারের জন্য ব্যবহৃত হয়।
What is the purpose of a database schema in PostgreSQL?
ANS: ডাটাবেস স্কিমা (schema) এর প্রধান উদ্দেশ্য হলো PostgreSQL-এর মধ্যে ডেটা অবজেক্টগুলো যেমন টেবিল, ভিউ, ইনডেক্স, ফাংশন ইত্যাদ) একটি লজিক্যাল গ্রুপে (namespace) সাজিয়ে রাখা
         * অবজেক্টের সংগঠন ও পৃথকীকরণ --> একই নামের টেবিল বা ফাংশন বিভিন্ন স্কিমায় থাকতে পারে, তাই নামের সংর্ঘষ এড়ানো যায়।
         * পারমিশন ও অ্যাক্সেস কন্ট্রোল --> স্কিমা লেভেলে GRANT/REVOKE করে নির্দিষ্ট ব্যবহারকারী বা রোলকে শুধু ওই স্কিমার অবজেক্টগুলোতে অ্যাক্সেস দিতে বা না দিতে পারা যায়।
         * লজিক্যাল মডুলারিটি -----> বড় প্রকল্পে প্রতিটি মডিউল বা সাবসিস্টেমের জন্য আলাদা স্কিমা তৈরি করা যায় (যেমন: “sales” স্কিমা, “hr” স্কিমা, “analytics” স্কিমা ইত্যাদি)।
         * নেমস্পেস ব্যবস্থাপনা ----> স্কিমা হল এক ধরনের নেমস্পেস, যেখানে অবজেক্টগুলোকে আলাদা নাম জায়গায় রাখা হয়।যদি কোন টেবিলের নাম পূর্বেই ডাটাবেসে ব্যবহার করা থাকে, তাহলে অন্য স্কিমায় একই নাম ব্যবহার করলেও কোনো সমস্যা হবে না, 
                                   কারণ পুরো নাম হবে <schema_name>.<object_name>।
                                   
Explain the Primary Key and Foreign Key concepts in PostgreSQL ?

ANS : প্রাইমারি কী (Primary Key)
      প্রাইমারি কী হলো একটি টেবিলের এমন একটি (বা একাধিক) কলাম যার মাধ্যমে প্রতিটি রেকর্ড (rows) অনন্য (unique) ভাবে চিহ্নিত করা যায়।
      ফরেন কী (Foreign Key)
      ফরেন কী হলো একটি কনস্ট্রেইন্ট যা একটি টেবিলের (সন্তান টেবিল) কলামকে অন্য টেবিলের (মূল টেবিল) প্রাইমারি কী (বা অনন্য কলাম) এর সাথে লিঙ্ক বা রিলেশনশিপ স্থাপন করে। 

What is the difference between the VARCHAR and CHAR data types?

ANS : 
     ১. স্টোরেজ ও দৈর্ঘ্য (Storage & Length)

          * CHAR(n)
          
                * এটি একটি fixed-length ডেটা টাইপ।
                * নির্দিষ্ট করা দৈর্ঘ্য (n) অনুযায়ী সবসময় একই জায়গা ব্যাবহার করে।
                * যদি সেলে প্রবেশ করানো স্ট্রিংটি n এর চেয়ে ছোট হয়, তখন PostgreSQL স্বয়ংক্রিয়ভাবে বাকি জায়গায় স্পেস (space) দিয়ে পূরণ করে (right-padded)।
                উদাহরণ:

                        
                         CREATE TABLE example_char (
                         code CHAR(5)
                          );
                         INSERT INTO example_char (code) VALUES ('AB');
                         SELECT length(code), '"' || code || '"' AS stored_value
                         FROM example_char;
                         
                উপরে length(code) দেখাবে 5, কারণ 'AB' এর পরে তিনটি স্পেস যোগ করে মোট ৫ অক্ষর হিসেবে স্টোর হবে।
                stored_value কলামে দেখা যাবে '"AB "' (“AB” এর পাশে তিনটি স্পেস)।

          * VARCHAR(n)
                * এটি একটি variable-length ডেটা টাইপ।
                * সর্বোচ্চ n অক্ষর পর্যন্ত স্টোর করতে পারে, তবে ছোট স্ট্রিং এন্ট্রি হলে শুধুমাত্র প্রয়োজনীয় জায়গাই নেয়।
                * কোন অতিরিক্ত স্পেস যোগ করে পূরণ করেনা।
                উদাহরণ:  
                        CREATE TABLE example_varchar (
                        name VARCHAR(10)
                        );
                        INSERT INTO example_varchar (name) VALUES ('Ram');
                        SELECT length(name), '"' || name || '"' AS stored_value
                        FROM example_varchar;
                এখানে length(name) হবে 3, কারণ ‘Ram’ মাত্র ৩ অক্ষর।
                stored_value দেখা যাবে '"Ram"' (কোনো অতিরিক্ত স্পেস নেই) |


      ২. পারফরম্যান্স (Performance)
             CHAR(n)

                 * যেহেতু সবসময় ঠিকঠাক n দৈর্ঘ্য ধরে (padding সহ), তাই যেকোনো রো (row) এর জন্য স্টোরেজ সাইজ অনুমানযোগ্য।
                 * খুব ছোট বান্ডেলের ক্ষেত্রে (যেমন, ঠিক ২-বাইট বা ৪-বাইট ভ্যারিয়েবল নয়, বরং fixed ১০০-বাইট) খুব হাই-ওলিউম ডেটাতে  “padding” ও “unpadding” এর মূল্য কিছুটা বাড়িয়ে দিতে পারে।
                 * মেমোরিতে (CPU cache) ব্রডকাস্ট অবস্থায় (fixed-length) একটু সুবিধে দিতে পারে, কিন্তু সামগ্রিকভাবে বড় মাপের টেক্সট বা ভ্যারিয়েবল লেন্থ ফিল্ডে CHAR কম উপযোগী।

            VARCHAR(n)
                 * ক্রমাগত ভ্যারিয়েবল দৈর্ঘ্যের কারণে স্টোরেজ সাইজ ছোট এবং ডাইনামিক, বিশেষ করে বিভিন্ন দৈর্ঘ্যের নাম/ডেসক্রিপশন ইত্যাদি ক্ষেত্রে বেশি কার্যকর।
                 * অতিরিক্ত স্পেস না থাকার কারণে সারি (row) যতটুকু জায়গা দখল করবে, সেটা তুলনামূলকভাবে কম হতে পারে।


 Explain the purpose of the WHERE clause in a SELECT statement ?
 
 ANS : WHERE ক্লজের মূল উদ্দেশ্য হলো SELECT (বা অন্য যেকোনো ডাটা ম্যানিপুলেশন—যেমন UPDATE, DELETE) স্টেটমেন্টে নির্দিষ্ট শর্ত (condition) প্রয়োগ করে শুধুমাত্র সেই রো (rows) বা ধারা (records) নির্বাচন করা । 
       সহজভাবে বলতে গেলে, WHERE ক্লজ দিয়ে আপনি “কোন রোগুলোকে নির্বাচিত (filter) করবে” তা নির্ধারণ করেন।


What are the LIMIT and OFFSET clauses used for?

ANS : LIMIT এবং OFFSET ক্লজগুলো মূলত বড় বা সম্ভাব্য অনেক রো হলো এমন কোয়েরির রেজাল্টকে নিয়ন্ত্রণ করার জন্য ব্যবহৃত হয়। এদের কাজ সহজভাবে বলতে গেলে:
          1. LIMIT দিয়ে আপনি নির্দিষ্ট সংখ্যা পর্যন্ত মাত্র রো রিটার্ন করতে বলতে পারেন।
          2. OFFSET দিয়ে আপনি প্রথম কতগুলো রো প্রয়োজন নেই (এগুলো বাগিয়েই) কত নম্বর রো থেকে শুরু করে রিটার্ন শুরু করবে, তা নির্দেশ করতে পারেন।


How can you modify data using UPDATE statements? 

ANS :   
                UPDATE <table_name>

                SET <column1> = <new_value1>,

                    <column2> = <new_value2>,

                [WHERE <condition>];


What is the significance of the JOIN operation, and how does it work in PostgreSQL?


ANS :    

        ১. JOIN এর গুরুত্ব (Significance)

                * একাধিক টেবিল থেকে প্রয়োজনীয় তথ্য এনে একত্রে ব্যবহারের জন্য JOIN অপরিহার্য, কারণ এক টেবিলেই সব ডেটা রাখা সঠিক নয়।

                * যদি আপনি চান প্রতিটি অর্ডারের সাথে গ্রাহকের নামও দেখতে, তাহলে একসাথে দুই টেবিল থেকে ডেটা টেনে আনতে হবে। JOIN ছাড়া এটা সম্ভব নয়।

                * ধরুন আপনার কাছে একটি customer টেবিল আছে যেখানে গ্রাহকের নাম ও আইডি আছে, আর অন্যদিকে একটি orders টেবিল আছে যেখানে প্রতিটি অর্ডারের আইডি, গ্রাহক আইডি (customer_id) ইত্যাদি রয়েছে।
                  যদি আপনি চান প্রতিটি অর্ডারের সাথে গ্রাহকের নামও দেখতে, তাহলে একসাথে দুই টেবিল থেকে ডেটা টেনে আনতে হবে। JOIN ছাড়া এটা সম্ভব নয়।

      ২. JOIN এর বেসিক কাজের ধরণ
                      1. INNER JOIN
                      2. LEFT (OUTER) JOIN
                      3. RIGHT (OUTER) JOIN
                      4. FULL (OUTER) JOIN
                      5. CROSS JOIN


Explain the GROUP BY clause and its role in aggregation operations ?

ANS :  

        GROUP BY ক্লজের কাজ
                        * ডেটাকে যেসব কলাম দিয়ে গোষ্ঠী (group) করতে চান, সেই কলামগুলো ব্যবহার করে একাধিক রোকে একত্রিত করে একটি গ্রুপ তৈরি করে দেয়।

        Rloe In Aggregate
                        * অ্যাগ্রিগেট ফাংশন (যেমন SUM(), AVG(), COUNT(), MAX() ইত্যাদি) গ্রুপের ভেতরের ডেটা নিয়ে একক ফলাফল তৈরি করে।



How can you calculate aggregate functions like COUNT(), SUM(), and AVG() in PostgreSQL?


ANS:  
        ১. COUNT() ফাংশন
                        COUNT() দিয়ে আপনি মোট কতটি রো (rows) বা মান (values) আছে তা গণনা করতে পারেন।

        ২. SUM() ফাংশন
                        SUM(<numeric_column>) দিয়ে আপনি নির্দিষ্ট কলামে থাকা সংখ্যাসমষ্টি (numeric total) হিসাব করতে পারেন।

                        শুধুমাত্র NULL ছাড়া বাকি সংখ্যাগুলো যোগ হয়।

        ৩. AVG() ফাংশন
                        AVG(<numeric_column>) দিয়ে নির্দিষ্ট কলামের গড় মান (average) পেতে পারেন।

        
                





